package nl.zeesoft.zdk.htm.enc;

import java.util.ArrayList;
import java.util.List;
import java.util.Map.Entry;
import java.util.SortedMap;
import java.util.TreeMap;

import nl.zeesoft.zdk.ZStringBuilder;
import nl.zeesoft.zdk.htm.util.SDR;

/**
 * A CombinedEncoder can be used to combine several encoders into one.
 */
public class CombinedEncoder {
	private int									length		= 0;
	private int									bits		= 0;
	private SortedMap<String,EncoderObject>		encoders	= new TreeMap<String,EncoderObject>();
	
	public CombinedEncoder() {
		initialize();
	}
	
	public CombinedEncoder(String name,EncoderObject encoder) {
		initialize();
		addEncoder(name,encoder);
	}
	
	/**
	 * Returns the length of the SDRs generated by this encoder.
	 * 
	 * @return The length
	 */
	public int length() {
		return length;
	}
	
	/**
	 * Returns the number of on bits of the SDRs generated by this encoder.
	 * 
	 * @return The number of on bits
	 */
	public int bits() {
		return bits;
	}
	
	/**
	 * Returns the description of the encoder.
	 * 
	 * @return The description
	 */
	public ZStringBuilder getDescription() {
		ZStringBuilder r = new ZStringBuilder(getClass().getSimpleName());
		r.append(" length: ");
		r.append("" + length);
		r.append(", bits: ");
		r.append("" + bits);
		for (Entry<String,EncoderObject> entry: encoders.entrySet()) {
			r.append("\n- ");
			r.append(entry.getKey());
			r.append(" ");
			ZStringBuilder desc = entry.getValue().getDescription();
			desc.replace("\n","\n  ");
			r.append(desc);
		}
		return r;
	}

	/**
	 * Returns a string builder representation the state of StateEncoderObject instances in this combined encoder.
	 * 
	 * @return The string builder
	 */
	public ZStringBuilder toStringBuilder() {
		ZStringBuilder r = new ZStringBuilder();
		for (Entry<String,EncoderObject> entry: encoders.entrySet()) {
			if (entry.getValue() instanceof StateEncoderObject) {
				StateEncoderObject enc = (StateEncoderObject) entry.getValue();
				if (r.length()>0) {
					r.append("|");
				}
				r.append("" + entry.getKey());
				r.append("=");
				r.append(enc.toStringBuilder());
			}
		}
		return r;
	}
	
	/**
	 * Initializes the state of StateEncoderObject instances in this combined encoder using a string builder.
	 * 
	 * @param str The string builder
	 */
	public void fromStringBuilder(ZStringBuilder str) {
		if (str.length()>0) {
			List<ZStringBuilder> elems = str.split("|");
			for (ZStringBuilder elem: elems) {
				List<ZStringBuilder> nameState = elem.split("=");
				if (nameState.size()>1) {
					EncoderObject e = encoders.get(nameState.get(0).toString());
					if (e!=null && e instanceof StateEncoderObject) {
						StateEncoderObject enc = (StateEncoderObject) e;
						enc.fromStringBuilder(nameState.get(1));
					}
				}
			}
		}
	}
	
	/**
	 * Initializes the combined encoder state to its defaults.
	 */
	public void initialize() {
		length = 0;
		bits = 0;
		encoders.clear();
	}
	
	/**
	 * Adds an encoder.
	 * 
	 * @param name The name of the encoder
	 * @param encoder The encoder
	 */
	public void addEncoder(String name,EncoderObject encoder) {
		length = length + encoder.length;
		bits = bits + encoder.bits;
		encoders.put(name,encoder);
	}
	
	/**
	 * Returns an encoded SDR for a map of named values assuming the names correspond to the names of the added encoders.
	 * 
	 * @param values The named value map
	 * @return The encoder SDR
	 */
	public SDR getSDRForValues(SortedMap<String,Float> values) {
		SDR r = null;
		for (Entry<String,EncoderObject> entry: encoders.entrySet()) {
			SDR add = null;
			Float value = values.get(entry.getKey());
			if (value==null) {
				add = new SDR(entry.getValue().length);
			} else {
				add = entry.getValue().getSDRForValue(value);
			}
			if (r==null) {
				r = add;
			} else {
				r = SDR.concat(r,add);
			}
		}
		return r;
	}
	
	/**
	 * Iterates through all possible values of the scalar encoders in this combined encoder to determine if the SDR values have a certain minimal and maximal overlap.
	 * 
	 * @return An empty string builder or a string builder containing an error message
	 */
	public ZStringBuilder testScalarOverlap() {
		ZStringBuilder r = new ZStringBuilder();
		for (String name: getEncoderNames()) {
			ScalarEncoder encoder = getScalarEncoder(name);
			if (encoder!=null) {
				ZStringBuilder err = ((ScalarEncoder) encoder).testScalarOverlap(1,encoder.bits - 1);
				if (err.length()>0) {
					if (r.length()>0) {
						r.append("\n");
					}
					r.append(name);
					r.append(": ");
					r.append(err);
				}
			}
		}
		return r;
	}
	
	protected List<EncoderObject> getEncoders() {
		List<EncoderObject> r = new ArrayList<EncoderObject>();
		for (EncoderObject encoder: encoders.values()) {
			r.add(encoder);
		}
		return r;
	}
	
	protected List<String> getEncoderNames() {
		List<String> r = new ArrayList<String>();
		for (String name: encoders.keySet()) {
			r.add(name);
		}
		return r;
	}
	
	protected EncoderObject getEncoder(String name) {
		return encoders.get(name);
	}
	
	protected ScalarEncoder getScalarEncoder(String name) {
		ScalarEncoder r = null;
		EncoderObject encoder = encoders.get(name);
		if (encoder instanceof ScalarEncoder) {
			r = (ScalarEncoder) encoder;
		}
		return r;
	}
}
